export algorithm2_two_machines_job_shop

"""
Struct representing a node in the network generated by the `two_machines_job_shop_generate_block_graph` for the two machines job shop problem.
# Fields
- `j::Vector{T_J}`: A vector of length `n` representing the current state of the jobs - `j[i]` is the number of the operations processsed for job `i`.
- `h::T_J`: The index of the main operation
- `t::Vector{T_P}`: A vector of length `m` representing the current state of the machines - `t[i]` is the time of the last operation processed on machine `i`.
- `times::Vector{NamedTuple{(:i,:j,:C), Tuple{T_J,T_J,T_P}}}`: A vector of named tuples representing the times of the operations processed in the node. Each named tuple has the fields `i`, `j` and `C`, where `i` is the job number, `j` is the operation number and `C` is the completion time of the operation.
"""
struct BlockEdge{T_J<:Integer, T_P<:Integer}
    j::Vector{T_J}
    h::T_J
    t::Vector{T_P}
    operation_times::Dict{Tuple{T_J, T_J}, T_P}
    BlockEdge(j::Vector{T_J}, h::T_J, t::Vector{T_P}) where {T_J <: Integer, T_P <: Integer} = new{T_J, T_P}(j, h, t, Dict{Tuple{T_J, T_J}, T_P}())
    BlockEdge(j::Vector{T_J}, h::T_J, t::Vector{T_P}, operation_times::Dict{Tuple{T_J, T_J}, T_P}) where {T_J <: Integer, T_P <: Integer}  = new{T_J, T_P}(j, h, t, operation_times)
end
 
"""
    algorithm2_two_machines_job_shop(instance::JobShopInstance; yielding::Bool=false)

Algorithm to solve a `J2 | n=k | Cmax` problem, with complexity `O(r^k)`, where `r = sum(n_i)` and `k = n`.

# Arguments
- `instance::JobShopInstance`: An instance of the two machines job shop problem.
- `yielding::Bool=false`: If `true`, the algorithm will yield after each iteration. This is useful for timeouting the algorithm.

# Returns
- `jobShopSchedule::ShopSchedule`: A ShopSchedule object representing the solution to the two machines job shop problem.

"""
function algorithm2_two_machines_job_shop(instance::JobShopInstance; yielding=false)
    # T_J jest najmniejszym możliwym indeksów wierzchołków grafów
    T_J::Type = all(instance.n_i .< typemax(Int8)) ? Int8 : all(instance.n_i .< typemax(Int16)) ? Int16 : all(instance.n_i .< typemax(Int32)) ? Int32 : Int64
    # T_P jest najmniejszym możliwym typem długości czasu wykonania
    T_P::Type = sum(sum(instance.p)) < typemax(Int8) ? Int8 : sum(sum(instance.p)) < typemax(Int16) ? Int16 : sum(sum(instance.p)) < typemax(Int32) ? Int32 : Int64
    # T_M jest najmniejszym możliwym typem indeksów maszyn
    T_M::Type = maximum(maximum(instance.μ)) < typemax(Int8) ? Int8 : maximum(maximum(instance.μ)) < typemax(Int16) ? Int16 : maximum(maximum(instance.μ)) < typemax(Int32) ? Int32 : Int64
    machine_equals(2)(instance) || throw(ArgumentError("The algorithm2_two_machines_job_shop algorithm can only be used for two machines job shop problems."))
    return _algorithm2_two_machines_job_shop(instance.n, instance.m, T_J.(instance.n_i), convert(Vector{Vector{T_P}},instance.p), convert(Vector{Vector{T_M}},instance.μ), instance, yielding)
end

function _algorithm2_two_machines_job_shop(
    n::Int64,
    m::Int64,
    n_i::Vector{T_J},
    p::Vector{Vector{T_P}},
    μ::Vector{Vector{T_M}},
    instance::JobShopInstance,
    yielding::Union{Bool, Nothing}
) where {T_J <: Integer, T_P <: Integer, T_M <: Integer} 
    # Za pomocą makra @timed możemy mierzyć czas i ilość zaalokowanej pamięci
    _ , timeSeconds, bytes = @timed begin 

    metadata = Dict{String, Any}()

    # parametr yielding określa nam, czy algorytm ma wywoływać funkcję yield() co określoną ilość czasu.
    # pozwala to na kończenie działania procedury po pewnej ilości czasu (timeouting)
    yield_ref = yielding ? Ref(time()) : nothing
    
    # generowanie grafu bloków operacji
    neighborhood, neighborhood_topological_sorted, average_nodes_created, max_nodes_created = _two_machines_job_shop_generate_network(n, m, n_i, p, μ, yield_ref)
    
    # Tablica previous wyznacza poprzedników wierzchołka
    previous = OffsetArray(
        Array{Vector{T_J}, n}(undef, (n_i .+ 1)...), 
        [-1 for _ in 1:n]...)

    # Tablica d do wyznaczania najkrótszej odległości w grafie od wierzchołka startowego
    d = OffsetArray(
        fill(typemax(T_P), Tuple(n_i .+ 1)), 
        [-1 for _ in 1:n]...)

    # wierzchołek starowy ma odległość zero
    d[CartesianIndex(zeros(T_P, n)...)] = T_P(0)

    # wyznaczenie kombinacji bloków operacji o najkrótszej długości
    for node in neighborhood_topological_sorted
        succesors = neighborhood[CartesianIndex((node...,))]
        for successor in succesors
            if d[CartesianIndex(successor.j...)] > d[CartesianIndex(node...)] + maximum(successor.t)
                d[CartesianIndex(successor.j...)] = d[CartesianIndex(node...)] + maximum(successor.t)
                previous[CartesianIndex(successor.j...)] = node
            end
        end
        try_yield(yield_ref)
    end

    # rekonstrukcja najkrótszej ścieżki
    C = reconstructpathalgorithm2(n, n_i, neighborhood, previous)

    metadata["constructed_nodes"] = length(neighborhood)
    metadata["average"] = average_nodes_created
    metadata["max"] = max_nodes_created
    
    end
    return ShopSchedule(
        instance, 
        convert(Vector{Vector{Int64}}, C),
        Int64(maximum(maximum.(C))),
        Cmax_function;
        algorithm="Algorithm2_TwoMachinesJobShop",
        timeSeconds=timeSeconds,
        memoryBytes=bytes,
        metadata=metadata
    )
end

sizeofdict(n_i) = reduce((*), n_i; init=1)

struct NeighborhoodOrdering <: Base.Order.Ordering end

Base.Order.lt(::NeighborhoodOrdering, x::Vector{T_J}, y::Vector{T_J}) where {T_J <: Integer} = all(x .≤ y) && x ≠ y

"""
Generates a network of blocks of operations for the two machines job shop problem.
"""
function _two_machines_job_shop_generate_network(
    n::Int64,
    m::Int64,
    n_i::Vector{T_J},
    p::Vector{Vector{T_P}},
    μ::Vector{Vector{T_M}},
    yield_ref::Union{Ref,Nothing}
) where {T_J <: Integer, T_P <: Integer, T_M <: Integer}
    # Wektor zawierający listę wierzchołków w grafie posortowanych topologicznie
    neighborhood_dag = Vector{T_J}[]
    sizehint!(neighborhood_dag, reduce((*), n_i .+ 1; init=1))

    # neighborhood jest tablicą wyznaczonych krawędzi (bloków) każdego wierzchołka
    neighborhood = OffsetArray(
        Array{Vector{BlockEdge{T_J, T_P}}, n}(undef, (n_i .+ 1)...), 
        [-1 for _ in 1:n]...)

    # Stos wierzchołków, które są w kolejce do wyznaczania sąsiadow
    stack = Stack{Vector{T_J}}()

    startNode = zeros(T_J, n)
    push!(stack, startNode)
    push!(neighborhood_dag, startNode)
    
    # Zbiór wierzchołków, które już pojawiłu się w `stack`
    stackVisited = OffsetArray(
        falses((n_i .+ 1)...),
        [-1 for _ in 1:n]...)
    stackVisited[CartesianIndex(startNode...)] = true
    average = 0
    i = 0
    maxi = 0

    while !isempty(stack)
        node = pop!(stack)
        # generowanie sąsiadów bloku
        blocks = _two_machines_job_shop_generate_block_graph(node, n, m, n_i, p, μ, yield_ref)

        percent =  (length(blocks) / sizeofdict((n_i .+ 1) .- node))
        average = (i*average + percent) / (i+1)
        i += 1
        maxi = max(maxi, percent)

        push!(neighborhood_dag, node)
        neighborhood[CartesianIndex(node...)] = blocks
        
        # jeśli jakiś wierzchołek jeszcze nie był na stosie, to go tam dodaj
        for block in blocks
            if !stackVisited[CartesianIndex(block.j...)]
                push!(stack, block.j)
                stackVisited[CartesianIndex(block.j...)] = true
            end
        end
    end
    sort!(neighborhood_dag, order=NeighborhoodOrdering())
    return neighborhood, neighborhood_dag, average, maxi
end

function _two_machines_job_shop_generate_block_graph(
    u::Vector{T_J},
    n::Int64,
    m::Int64,
    n_i::Vector{T_J},
    p::Vector{Vector{T_P}},
    μ::Vector{Vector{T_M}},
    yield_ref::Union{Ref,Nothing}
) where {T_J <: Integer, T_P <: Integer, T_M <: Integer}
    r = sum(n_i)
    k = n 

    # Wektor już wyznaczonych sąsiadów bloku startowego 
    barNodes = Vector{BlockEdge{T_J, T_P}}()

    # Zbiór już wyznaczonych sąsiadów bloku startowego
    barNodesSet = Set{Vector{T_J}}()
    sizehint = floor(Int, sizeofdict((n_i .+ 1) .- u) * 0.12)
    sizehint!(barNodesSet, sizehint)
    
    
    # Stos wierzchołków, do wyznacznia sąsiadów
    barNodesStack = Stack{BlockEdge{T_J, T_P}}()
    s = BlockEdge(u, T_J(0), T_P[0, 0])
    # push!(barNodes, s)
    push!(barNodesStack, s)
    # push!(barNodesSet, s.j)

    while !isempty(barNodesStack)
        # ściągamy wierzchołek ze stosu, i tworzymy n kopii, w każdej dodając jedną operację z każdego zadania do bloku
        node = pop!(barNodesStack)
        try_yield(yield_ref)
        for i = 1:n
            j = copy(node.j)
            j[i] += 1
            

            # jeśli wszystkie operacje dla zadania i zostały już uszeregowane w bloku, to nie dodajemy nowego wierzchołka
            if j[i] > n_i[i]
                continue
            end
            μ_ij = μ[i][j[i]]
            t = copy(node.t)    
            operation_times = copy(node.operation_times)
            # ustalamy czas zakończenia operacji na maszynie μ_ij, czyli na tej, która jest przypisana do operacji
            if (j - s.j)[i] > 1 && t[μ_ij] < get(operation_times,(i,j[i]-1),T_P(0))
                continue
            end

            t[μ_ij] = t[μ_ij] + p[i][j[i]]
            
            operation_times[(i,j[i])] = t[μ_ij]
            # times = copy(node.times)
            # dodajemy czas zakończenia operacji do wektora times
            # push!(times, (i=i, j=j[i], C=t[μ_ij]))
            newnode::Union{BlockEdge,Nothing} = nothing

            # jeśli node jest wektorem startowym, to dodajemy nowy wierzchołek do grafu
            if node.j == s.j
                newnode = BlockEdge(j, T_J(i), t, operation_times)
            else
                # dodawanie zgodnie z reguła zapisaną w Brucker
                if node.t[1] >= node.t[2] && μ_ij == 1
                    newnode = nothing
                elseif node.t[2] >= node.t[1] && μ_ij == 2
                    newnode = nothing
                else
                    newnode = BlockEdge(j, T_J(i), t, operation_times)
                end
            end
            if newnode !== nothing && newnode.j ∉ barNodesSet
                push!(barNodes, newnode)
                push!(barNodesStack, newnode)
                push!(barNodesSet, newnode.j)
            end
        end
    end
    return barNodes
end

function reconstructpathalgorithm2(
    n::Int,
    n_i::Vector{T_J},
    neighborhood,
    previous
) where {T_J <: Integer}
    r = sum(n_i)
    k = length(n_i)
    C = [[0 for _ in 1:n_i[i]] for i in 1:n]
    path = Vector{Vector{T_J}}()
    current = [n_i[i] for i in 1:n]
    while current !== nothing
        pushfirst!(path, current)
        current = isassigned(previous,CartesianIndex(current...)) ? previous[CartesianIndex(current...)] : nothing
    end
    max_time = 0
    for (point1, point2) in zip(path, Iterators.drop(path, 1))
        current_neighbors = neighborhood[CartesianIndex(point1...)]
        times_index = findfirst(x -> x.j == point2, current_neighbors)
        times = current_neighbors[times_index].operation_times
        for ((i,j), C_ij) in times
            C[i][j] = max_time + C_ij
        end
        max_time = maximum(maximum.(C))
    end
    return C
end
