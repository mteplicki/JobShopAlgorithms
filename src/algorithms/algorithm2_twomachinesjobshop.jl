export algorithm2_two_machines_job_shop

"""
Struct representing a node in the network generated by the `two_machines_job_shop_generate_block_graph` for the two machines job shop problem.
# Fields
- `j::Vector{T_J}`: A vector of length `n` representing the current state of the jobs - `j[i]` is the number of the operations processsed for job `i`.
- `h::T_J`: The index of the main operation
- `t::Vector{T_P}`: A vector of length `m` representing the current state of the machines - `t[i]` is the time of the last operation processed on machine `i`.
- `times::Vector{NamedTuple{(:i,:j,:C), Tuple{T_J,T_J,T_P}}}`: A vector of named tuples representing the times of the operations processed in the node. Each named tuple has the fields `i`, `j` and `C`, where `i` is the job number, `j` is the operation number and `C` is the completion time of the operation.
"""
struct BarNode{T_J<:Integer, T_P<:Integer}
    j::Vector{T_J}
    h::T_J
    t::Vector{T_P}
    times::Vector{NamedTuple{(:i,:j,:C), Tuple{T_J,T_J,T_P}}}
    operation_times::Vector{Vector{T_P}}
    BarNode(j::Vector{T_J}, h::T_J, t::Vector{T_P}) where {T_J <: Integer, T_P <: Integer} = new{T_J, T_P}(j, h, t, [], [])
    BarNode(j::Vector{T_J}, h::T_J, t::Vector{T_P}, times::Vector{NamedTuple{(:i,:j,:C), Tuple{T_J,T_J,T_P}}}) where {T_J <: Integer, T_P <: Integer}  = new{T_J, T_P}(j, h, t, times, [])
    BarNode(j::Vector{T_J}, h::T_J, t::Vector{T_P}, times::Vector{NamedTuple{(:i,:j,:C), Tuple{T_J,T_J,T_P}}}, operation_times::Vector{Vector{T_P}}) where {T_J <: Integer, T_P <: Integer}  = new{T_J, T_P}(j, h, t, times, operation_times)
end
 
"""
    algorithm2_two_machines_job_shop(instance::JobShopInstance; yielding::Bool=false)

Algorithm to solve a `J2 | n=k | Cmax` problem, with complexity `O(r^k)`, where `r = sum(n_i)` and `k = n`.

# Arguments
- `instance::JobShopInstance`: An instance of the two machines job shop problem.
- `yielding::Bool=false`: If `true`, the algorithm will yield after each iteration. This is useful for timeouting the algorithm.

# Returns
- `jobShopSchedule::ShopSchedule`: A ShopSchedule object representing the solution to the two machines job shop problem.

"""
function algorithm2_two_machines_job_shop(instance::JobShopInstance; yielding=false)
    T_J::Type = all(instance.n_i .< typemax(Int8)) ? Int8 : all(instance.n_i .< typemax(Int16)) ? Int16 : all(instance.n_i .< typemax(Int32)) ? Int32 : Int64
    T_P::Type = sum(sum(instance.p)) < typemax(Int8) ? Int8 : sum(sum(instance.p)) < typemax(Int16) ? Int16 : sum(sum(instance.p)) < typemax(Int32) ? Int32 : Int64
    T_M::Type = maximum(maximum(instance.μ)) < typemax(Int8) ? Int8 : maximum(maximum(instance.μ)) < typemax(Int16) ? Int16 : maximum(maximum(instance.μ)) < typemax(Int32) ? Int32 : Int64
    machine_equals(2)(instance) || throw(ArgumentError("The algorithm2_two_machines_job_shop algorithm can only be used for two machines job shop problems."))
    return _algorithm2_two_machines_job_shop(instance.n, instance.m, T_J.(instance.n_i), convert(Vector{Vector{T_P}},instance.p), convert(Vector{Vector{T_M}},instance.μ), instance, yielding)
end

function _algorithm2_two_machines_job_shop(
    n::Int64,
    m::Int64,
    n_i::Vector{T_J},
    p::Vector{Vector{T_P}},
    μ::Vector{Vector{T_M}},
    instance::JobShopInstance,
    yielding::Union{Bool, Nothing}
) where {T_J <: Integer, T_P <: Integer, T_M <: Integer} 
    _ , timeSeconds, bytes = @timed begin 
    yield_ref = yielding ? Ref(time()) : nothing
    metadata = Dict{String, Any}()
    r = sum(n_i)
    k = n
    # Dict() do wyznaczania poprzedników najkrótszych ścieżek w grafie
    previous = Dict{Vector{T_J}, Vector{T_J}}()
    # Dict() do wyznaczania najkrótszej odległości w grafie od wierzchołka startowego
    d = Dict{Vector{T_J}, T_P}()
    sizehint = sizeofdict(n_i)
    sizehint!(previous, sizehint) 
    sizehint!(d, sizehint)
    d[zeros(T_P, n)] = T_P(0)
    # generowanie grafu bloków operacji
    neighborhood, neighborhood_dag = two_machines_job_shop_generate_network(n, m, n_i, p, μ, yield_ref)
    # wyznaczenie kombinacji bloków operacji o najkrótszej długości
    for node in neighborhood_dag
        succesors = neighborhood[node]
        for successor in succesors
            if get(d,successor.j, typemax(T_P)) > d[node] + maximum(successor.t)
                d[successor.j] = d[node] + maximum(successor.t)
                previous[successor.j] = node
            end
        end
        try_yield(yield_ref)
    end

    # rekonstrukcja najkrótszej ścieżki
    C = reconstructpathalgorithm2(n, n_i, neighborhood, previous)
    try_yield(yield_ref)
    metadata["constructed_nodes"] = length(neighborhood)
    end
    return ShopSchedule(
        instance, 
        convert(Vector{Vector{Int64}}, C),
        Int64(maximum(maximum.(C))),
        Cmax_function;
        algorithm="Algorithm2_TwoMachinesJobShop",
        timeSeconds=timeSeconds,
        memoryBytes=bytes,
        metadata=metadata
    )
end

sizeofdict(n_i) = reduce((*), n_i; init=1)

struct NeighborhoodOrdering <: Base.Order.Ordering end

Base.Order.lt(::NeighborhoodOrdering, x::Vector{T_J}, y::Vector{T_J}) where {T_J <: Integer} = all(x .≤ y) && x ≠ y

"""
Generates a network of blocks of operations for the two machines job shop problem.
"""
function two_machines_job_shop_generate_network(
    n::Int64,
    m::Int64,
    n_i::Vector{T_J},
    p::Vector{Vector{T_P}},
    μ::Vector{Vector{T_M}},
    yield_ref::Union{Ref,Nothing}
) where {T_J <: Integer, T_P <: Integer, T_M <: Integer}
    # Dict() wyznaczający sąsiadów w grafie bloków operacji 
    neighborhood_dag = Vector{T_J}[]
    neighborhood = Dict{Vector{T_J}, Vector{BarNode{T_J, T_P}}}()
    sizehint = sizeofdict(n_i)
    sizehint!(neighborhood, sizehint) 
    sizehint!(neighborhood_dag, sizehint)

    # Stos wierzchołków, do wyznacznia sąsiadów
    stack = Stack{Vector{T_J}}()
    startNode = zeros(T_J, n)
    push!(stack, startNode)
    push!(neighborhood_dag, startNode)

    # Zbiór wierzchołków, które już pojawiłu się w `stack`
    stackSet = Set{Vector{T_J}}()
    sizehint!(stackSet, sizehint)
    push!(stackSet, startNode)

    while !isempty(stack)
        node = pop!(stack)
        # generowanie sąsiadów bloku
        barNodes = two_machines_job_shop_generate_block_graph(node, n, m, n_i, p, μ, yield_ref)
        
        neighborhood[node] = barNodes
        push!(neighborhood_dag, node)
        # jeśli jakiś wierzchołek jeszcze nie został wyznaczony, dodaj go do stosu
        for barNode in filter(x -> x.j ∉ stackSet, barNodes)
            push!(stack, barNode.j)
            push!(stackSet, barNode.j)
        end
    end
    sort!(neighborhood_dag, lt=(x,y)->(all(x .≤ y) && x ≠ y))
    return neighborhood, neighborhood_dag
end

function two_machines_job_shop_generate_block_graph(
    u::Vector{T_J},
    n::Int64,
    m::Int64,
    n_i::Vector{T_J},
    p::Vector{Vector{T_P}},
    μ::Vector{Vector{T_M}},
    yield_ref::Union{Ref,Nothing}
) where {T_J <: Integer, T_P <: Integer, T_M <: Integer}
    r = sum(n_i)
    k = n 

    # Wektor już wyznaczonych sąsiadów bloku startowego 
    barNodes = Vector{BarNode{T_J, T_P}}()

    # Zbiór już wyznaczonych sąsiadów bloku startowego
    barNodesSet = Set{Vector{T_J}}()
    sizehint = sizeofdict(n_i)
    sizehint!(barNodesSet, sizehint)
    
    # Stos wierzchołków, do wyznacznia sąsiadów
    barNodesStack = Stack{BarNode{T_J, T_P}}()
    s = BarNode(u, T_J(0), T_P[0, 0], NamedTuple{(:i,:j,:C), Tuple{T_J,T_J,T_P}}[], [[T_P(0) for _ in 1:n_i[i]] for i in 1:n])
    # push!(barNodes, s)
    push!(barNodesStack, s)
    # push!(barNodesSet, s.j)

    while !isempty(barNodesStack)
        # ściągamy wierzchołek ze stosu, i tworzymy n kopii, w każdej dodając jedną operację z każdego zadania do bloku
        node = pop!(barNodesStack)
        try_yield(yield_ref)
        for i = 1:n
            j = copy(node.j)
            j[i] += 1
            

            # jeśli wszystkie operacje dla zadania i zostały już uszeregowane w bloku, to nie dodajemy nowego wierzchołka
            if j[i] > n_i[i]
                continue
            end
            μ_ij = μ[i][j[i]]
            t = copy(node.t)    
            operation_times = deepcopy(node.operation_times)
            # ustalamy czas zakończenia operacji na maszynie μ_ij, czyli na tej, która jest przypisana do operacji
            if (j - s.j)[i] > 1 && t[μ_ij] < operation_times[i][j[i]-1]
                continue
            end

            t[μ_ij] = t[μ_ij] + p[i][j[i]]
            
            operation_times[i][j[i]] = t[μ_ij]
            times = copy(node.times)
            # dodajemy czas zakończenia operacji do wektora times
            push!(times, (i=i, j=j[i], C=t[μ_ij]))
            newnode::Union{BarNode,Nothing} = nothing

            # jeśli node jest wektorem startowym, to dodajemy nowy wierzchołek do grafu
            if node.j == s.j
                newnode = BarNode(j, T_J(i), t, times, operation_times)
            else
                # dodawanie zgodnie z reguła zapisaną w Brucker
                if node.t[1] >= node.t[2] && μ_ij == 1
                    newnode = nothing
                elseif node.t[2] >= node.t[1] && μ_ij == 2
                    newnode = nothing
                else
                    newnode = BarNode(j, T_J(i), t, times, operation_times)
                end
            end
            if newnode !== nothing && newnode.j ∉ barNodesSet
                # if s.j == [0,0,0,0,0] && ( j == [2,0,3,0,1] || j == [1,0,2,0,1])
                #     println("debug1: $j")
                # end
                # if s.j == [1,0,2,0,1] && j == [2,0,3,0,1]
                #     println("debug2: $j")
                # end
                # if s.j == [2,0,3,0,1] && j == [3,0,3,0,1]
                #     println("debug3: $j")
                # end
                # if s.j == [3,0,3,0,1] && j == [3,0,4,0,1]
                #     println("debug4: $j")
                # end
                # if s.j == [3,0,4,0,1] && j == [3,0,5,0,1]
                #     println("debug5: $j")
                # end
                # if s.j == [3,0,5,0,1] && j == [4,0,6,0,1]
                #     println("debug6: $j")
                # end
                # if s.j == [4,0,6,0,1] && j == [4,0,6,1,1]
                #     println("debug7: $j")
                # end
                # if s.j == [4,0,6,1,1] && j == [4,0,6,2,2]
                #     println("debug8: $j")
                # end
                # if s.j == [4,0,6,2,2] && j == [5,2,6,2,3]
                #     println("debug9: $j")
                # end
                # if s.j == [5,2,6,2,3] && j == [6,4,6,6,6]
                #     println("debug10: $j")
                # end
                # if s.j == [6,4,6,6,6] && j == [6,5,6,6,6]
                #     println("debug11: $j")
                # end
                # if s.j == [6,5,6,6,6] && j == [6,6,6,6,6]
                #     println("debug12: $j")
                # end
                push!(barNodes, newnode)
                push!(barNodesStack, newnode)
                push!(barNodesSet, newnode.j)
            end
        end
    end
    # if s.j == [6,5,6,6,6]
    #     println("neighborhood of $(s.j): $(map(x->x.j,barNodes))")
    # end
    return barNodes
end

function reconstructpathalgorithm2(
    n::Int,
    n_i::Vector{T_J},
    neighborhood::Dict{Vector{T_J}, Vector{BarNode{T_J, T_P}}},
    previous::Dict{Vector{T_J}, Vector{T_J}}
) where {T_J <: Integer, T_P <: Integer}
    r = sum(n_i)
    k = length(n_i)
    C = [[0 for _ in 1:n_i[i]] for i in 1:n]
    path = Vector{Vector{T_J}}()
    current = [n_i[i] for i in 1:n]
    while current !== nothing
        pushfirst!(path, current)
        current = get(previous, current, nothing)
    end
    max_time = 0
    for (point1, point2) in zip(path, Iterators.drop(path, 1))
        current_neighbors = neighborhood[point1]
        times_index = findfirst(x -> x.j == point2, current_neighbors)
        times = current_neighbors[times_index].times
        for time in times
            i,j,C_ij = time.i, time.j, time.C
            C[i][j] = max_time + C_ij
        end
        max_time = maximum(maximum.(C))
    end
    return C

    
end
