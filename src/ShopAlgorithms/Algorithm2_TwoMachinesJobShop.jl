export algorithm2_two_machines_job_shop
"""
Struct representing a node in the network generated by the `two_machines_job_shop_generate_block_graph` for the two machines job shop problem.
# Fields
- `j::Vector{T_J}`: A vector of length `n` representing the current state of the jobs - `j[i]` is the number of the operations processsed for job `i`.
- `h::T_J`: The index of the main operation
- `t::Vector{T_P}`: A vector of length `m` representing the current state of the machines - `t[i]` is the time of the last operation processed on machine `i`.
- `times::Vector{NamedTuple{(:i,:j,:C), Tuple{T_J,T_J,T_P}}}`: A vector of named tuples representing the times of the operations processed in the node. Each named tuple has the fields `i`, `j` and `C`, where `i` is the job number, `j` is the operation number and `C` is the completion time of the operation.
"""
struct BarNode{T_J<:Integer, T_P<:Integer}
    j::Vector{T_J}
    h::T_J
    t::Vector{T_P}
    times::Vector{NamedTuple{(:i,:j,:C), Tuple{T_J,T_J,T_P}}}
    BarNode(j::Vector{T_J}, h::T_J, t::Vector{T_P}) where {T_J <: Integer, T_P <: Integer} = new{T_J, T_P}(j, h, t, [])
    BarNode(j::Vector{T_J}, h::T_J, t::Vector{T_P}, times::Vector{NamedTuple{(:i,:j,:C), Tuple{T_J,T_J,T_P}}}) where {T_J <: Integer, T_P <: Integer}  = new{T_J, T_P}(j, h, t, times)
end
 
"""
    algorithm2_two_machines_job_shop(instance::JobShopInstance)

Algorithm to solve a `J2 | n=k | Cmax` problem, with complexity `O(r^k)`, where `r = sum(n_i)` and `k = n`.

# Arguments
- `instance::JobShopInstance`: An instance of the two machines job shop problem.

# Returns
- `jobShopSchedule::ShopSchedule`: A ShopSchedule object representing the solution to the two machines job shop problem.

"""
function algorithm2_two_machines_job_shop(instance::JobShopInstance)
    T_J::Type = all(instance.n_i .< typemax(Int8)) ? Int8 : all(instance.n_i .< typemax(Int16)) ? Int16 : all(instance.n_i .< typemax(Int32)) ? Int32 : Int64
    T_P::Type = sum(sum(instance.p)) < typemax(Int8) ? Int8 : sum(sum(instance.p)) < typemax(Int16) ? Int16 : sum(sum(instance.p)) < typemax(Int32) ? Int32 : Int64
    T_M::Type = maximum(maximum(instance.μ)) < typemax(Int8) ? Int8 : maximum(maximum(instance.μ)) < typemax(Int16) ? Int16 : maximum(maximum(instance.μ)) < typemax(Int32) ? Int32 : Int64
    return algorithm2_two_machines_job_shop(instance.n, instance.m, T_J.(instance.n_i), convert(Vector{Vector{T_P}},instance.p), convert(Vector{Vector{T_M}},instance.μ))
end

function algorithm2_two_machines_job_shop(
    n::Int64,
    m::Int64,
    n_i::Vector{T_J},
    p::Vector{Vector{T_P}},
    μ::Vector{Vector{T_M}}
) where {T_J <: Integer, T_P <: Integer, T_M <: Integer}
    r = sum(n_i)
    k = n
    # Dict() do wyznaczania poprzedników najkrótszych ścieżek w grafie
    previous = Dict{Vector{T_J}, Vector{T_J}}()
    # Dict() do wyznaczania najkrótszej odległości w grafie od wierzchołka startowego
    d = Dict{Vector{T_J}, T_P}()
    sizehint = sum(n_i)^n ÷ 1000
    sizehint!(previous, sizehint) 
    sizehint!(d, sizehint)
    d[zeros(T_P, n)] = T_P(0)
    # generowanie grafu bloków operacji
    neighborhood = two_machines_job_shop_generate_network(n, m, n_i, p, μ)
    # wyznaczenie kombinacji bloków operacji o najkrótszej długości
    for (node, succesors) in neighborhood
        for successor in succesors
            if get(d,successor.j, typemax(T_P)) > d[node] + maximum(successor.t)
                d[successor.j] = d[node] + maximum(successor.t)
                previous[successor.j] = node
            end
        end
    end

    # rekonstrukcja najkrótszej ścieżki
    C = reconstructpathalgorithm2(n, n_i, neighborhood, previous)

    return ShopSchedule(
        JobShopInstance(n, m, Int64.(n_i), convert(Vector{Vector{Int64}}, p), convert(Vector{Vector{Int64}}, μ)), 
        convert(Vector{Vector{Int64}}, C),
        Int64(maximum(maximum.(C)))
    )
end

sizeofdict(n_i,k) = reduce((*), n_i .^ k; init=1)

"""
Generates a network of blocks of operations for the two machines job shop problem.
"""
function two_machines_job_shop_generate_network(
    n::Int64,
    m::Int64,
    n_i::Vector{T_J},
    p::Vector{Vector{T_P}},
    μ::Vector{Vector{T_M}}
) where {T_J <: Integer, T_P <: Integer, T_M <: Integer}
    # Dict() wyznaczający sąsiadów w grafie bloków operacji 
    neighborhood = OrderedDict{Vector{T_J}, Vector{BarNode{T_J, T_P}}}()
    sizehint = sum(n_i)^n ÷ 1000
    sizehint!(neighborhood, sizehint) 

    # Stos wierzchołków, do wyznacznia sąsiadów
    stack = Vector{Vector{T_J}}()
    startNode = zeros(T_J, n)
    push!(stack, startNode)

    # Zbiór wierzchołków, które już pojawiłu się w `stack`
    stackSet = Set{Vector{T_J}}()
    sizehint!(stackSet, sizehint)
    push!(stackSet, startNode)

    while !isempty(stack)
        node = pop!(stack)
        # generowanie sąsiadów bloku
        barNodes = two_machines_job_shop_generate_block_graph(node, n, m, n_i, p, μ)
        neighborhood[node] = barNodes
        # jeśli jakiś wierzchołek jeszcze nie został wyznaczony, dodaj go do stosu
        for barNode in filter(x -> x.j ∉ stackSet, barNodes)
            push!(stack, barNode.j)
            push!(stackSet, barNode.j)
        end
    end

    return neighborhood

end

function two_machines_job_shop_generate_block_graph(
    u::Vector{T_J},
    n::Int64,
    m::Int64,
    n_i::Vector{T_J},
    p::Vector{Vector{T_P}},
    μ::Vector{Vector{T_M}}
) where {T_J <: Integer, T_P <: Integer, T_M <: Integer}
    r = sum(n_i)
    k = n 

    # Wektor już wyznaczonych sąsiadów bloku startowego 
    barNodes = Vector{BarNode{T_J, T_P}}()

    # Zbiór już wyznaczonych sąsiadów bloku startowego
    barNodesSet = Set{Vector{T_J}}()
    sizehint = sum(n_i)^n ÷ 1000 
    sizehint!(barNodesSet, sizehint)
    
    # Stos wierzchołków, do wyznacznia sąsiadów
    barNodesStack = Stack{BarNode{T_J, T_P}}()
    s = BarNode(u, T_J(0), T_P[0, 0])
    push!(barNodes, s)
    push!(barNodesStack, s)
    push!(barNodesSet, s.j)

    while !isempty(barNodesStack)
        # ściągamy wierzchołek ze stosu, i tworzymy n kopii, w każdej dodając jedną operację z każdego zadania do bloku
        node = pop!(barNodesStack)
        for i = 1:n
            j = copy(node.j)
            j[i] += 1
            # jeśli wszystkie operacje dla zadania i zostały już uszeregowane w bloku, to nie dodajemy nowego wierzchołka
            if j[i] > n_i[i]
                continue
            end
            μ_ij = μ[i][j[i]]
            t = copy(node.t)    
            # ustalamy czas zakończenia operacji na maszynie μ_ij, czyli na tej, która jest przypisana do operacji
            t[μ_ij] += p[i][j[i]]
            times = copy(node.times)
            # dodajemy czas zakończenia operacji do wektora times
            push!(times, (i=i, j=j[i], C=t[μ_ij]))
            newnode::Union{BarNode,Nothing} = nothing

            # jeśli node jest wektorem startowym, to dodajemy nowy wierzchołek do grafu
            if node.j == s.j
                newnode = BarNode(j, T_J(i), t, times)
            else
                # dodawanie zgodnie z reguła zapisaną w Brucker
                if node.t[1] > node.t[2] && μ_ij == 1
                    newnode = nothing
                elseif node.t[2] > node.t[1] && μ_ij == 2
                    newnode = nothing
                else
                    newnode = BarNode(j, T_J(i), t, times)
                end
            end
            if newnode !== nothing && newnode.j ∉ barNodesSet
                push!(barNodes, newnode)
                push!(barNodesStack, newnode)
                push!(barNodesSet, newnode.j)
            end
        end
    end
    return barNodes
end

function reconstructpathalgorithm2(
    n::Int,
    n_i::Vector{T_J},
    neighborhood::OrderedDict{Vector{T_J}, Vector{BarNode{T_J, T_P}}},
    previous::Dict{Vector{T_J}, Vector{T_J}}
) where {T_J <: Integer, T_P <: Integer}
    r = sum(n_i)
    k = length(n_i)
    C = [[0 for _ in 1:n_i[i]] for i in 1:n]
    path = Vector{Vector{T_J}}()
    current = [n_i[i] for i in 1:n]
    while current !== nothing
        pushfirst!(path, current)
        current = get(previous, current, nothing)
    end
    max_time = 0
    for (point1, point2) in zip(path, Iterators.drop(path, 1))
        current_neighbors = neighborhood[point1]
        times_index = findfirst(x -> x.j == point2, current_neighbors)
        times = current_neighbors[times_index].times
        for time in times
            i,j,C_ij = time.i, time.j, time.C
            C[i][j] = max_time + C_ij
        end
        max_time = maximum(maximum.(C))
    end
    return C

    
end
