var documenterSearchIndex = {"docs":
[{"location":"constraints/#Constraints","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Package Constrains provides a set of functions for working with constraints dedicated to the Job Shop Scheduling Problem.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Modules = [Constraints]\nOrder   = [:constant, :type, :function]\nPrivate = false","category":"page"},{"location":"constraints/#ShopAlgorithms.Constraints.job_equals-Tuple{Int64}","page":"Constraints","title":"ShopAlgorithms.Constraints.job_equals","text":"job_equals(to::Int)\n\nReturns a function that takes an instance and returns a boolean indicating whether the instance's number of jobs is equal to the given integer to.\n\nArguments\n\nto::Int: The integer to compare the instance's number of jobs.\n\nReturns\n\nA function that takes an instance and returns a boolean indicating whether the instance's number of jobs is equal to the given integer to.\n\n\n\n\n\n","category":"method"},{"location":"constraints/#ShopAlgorithms.Constraints.job_lower_limit-Tuple{Int64}","page":"Constraints","title":"ShopAlgorithms.Constraints.job_lower_limit","text":"job_lower_limit(limit::Int)\n\nCheck if the number of jobs in the instance is greater than or equal to the given limit.\n\nArguments\n\nlimit::Int: The lower limit to check against the number of jobs in the instance.\n\nReturns\n\nA function that takes an instance and returns a boolean value:  true if the number of jobs in the instance is greater than or equal to the given limit, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"constraints/#ShopAlgorithms.Constraints.job_recirculation-Tuple{}","page":"Constraints","title":"ShopAlgorithms.Constraints.job_recirculation","text":"machine_repetition()\n\nReturns a function indicating whether any machine is repeated in the instance.\n\nReturns\n\nA function that takes an instance and returns a boolean value: true if any machine is repeated in the instance, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"constraints/#ShopAlgorithms.Constraints.job_upper_limit-Tuple{Int64}","page":"Constraints","title":"ShopAlgorithms.Constraints.job_upper_limit","text":"job_upper_limit(limit::Int)\n\nCheck if the number of jobs in the instance is lower than or equal to the given limit.\n\nArguments\n\nlimit::Int: The upper limit to check against the number of jobs in the instance.\n\nReturns\n\nA function that takes an instance and returns a boolean value:  true if the number of jobs in the instance is less than or equal to the given limit, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"constraints/#ShopAlgorithms.Constraints.machine_equals-Tuple{Int64}","page":"Constraints","title":"ShopAlgorithms.Constraints.machine_equals","text":"machine_equals(to::Int)\n\nReturns a function that takes an instance and returns a boolean indicating whether the instance's m field is equal to the given integer to.\n\nArguments\n\nto::Int: The integer to compare the instance's m field to.\n\nReturns\n\nA function that takes an instance and returns a boolean indicating whether the instance's m field is equal to the given integer to.\n\n\n\n\n\n","category":"method"},{"location":"constraints/#ShopAlgorithms.Constraints.machine_lower_limit-Tuple{Int64}","page":"Constraints","title":"ShopAlgorithms.Constraints.machine_lower_limit","text":"machine_lower_limit(limit::Int)\n\nChecks if the lower limit of the machine is greater than or equal to the given limit.\n\nArguments\n\nlimit::Int: the limit to check against the lower limit of the machine.\n\nReturns\n\nfunction that takes an instance of the problem and returns a boolean value:  true if the lower limit of the machine is greater than or equal to the given limit, false otherwise.    \n\n\n\n\n\n","category":"method"},{"location":"constraints/#ShopAlgorithms.Constraints.machine_repetition-Tuple{}","page":"Constraints","title":"ShopAlgorithms.Constraints.machine_repetition","text":"machine_repetition()\n\nReturns a function indicating whether any jobs has to be processed in the same machine more than once in a row.\n\nReturns\n\nA function that takes an instance and returns a boolean value: true if any jobs has to be processed in the same machine more than once in a row, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"constraints/#ShopAlgorithms.Constraints.machine_upper_limit-Tuple{Int64}","page":"Constraints","title":"ShopAlgorithms.Constraints.machine_upper_limit","text":"machine_upper_limit(limit::Int)\n\nChecks if the upper limit of the machine is less than or equal to the given limit.\n\nArguments\n\nlimit::Int: The maximum limit allowed for the machine.\n\nReturns\n\na function that takes an instance of the problem and returns a boolean value: true if the upper limit of the machine is less than or equal to the given limit, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"constraints/#ShopAlgorithms.Constraints.processing_time_lower_limit-Tuple{Int64}","page":"Constraints","title":"ShopAlgorithms.Constraints.processing_time_lower_limit","text":"processing_time_lower_limit(limit::Int)\n\nReturns a funtion indicating whether all processing times in the instance are greater than or equal to the given limit.\n\nArguments\n\nlimit::Int: The lower limit for processing times.\n\nReturns\n\nA function that takes an instance and returns a boolean value: true if all processing times in the instance are greater than or equal to the given limit, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"constraints/#ShopAlgorithms.Constraints.processing_time_upper_limit-Tuple{Int64}","page":"Constraints","title":"ShopAlgorithms.Constraints.processing_time_upper_limit","text":"processing_time_upper_limit(limit::Int)\n\nReturns a function indicating whether all processing times in the instance are less than or equal to the given limit.\n\nArguments\n\nlimit::Int: The upper limit for processing times.\n\nReturns\n\nA function that takes an instance and returns a boolean value: true if all processing times in the instance are less than or equal to the given limit, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"instance_loaders/#Instance-Loaders","page":"InstanceLoaders","title":"Instance Loaders","text":"","category":"section"},{"location":"instance_loaders/","page":"InstanceLoaders","title":"InstanceLoaders","text":"The InstanceLoaders module provides functions to load instances from files. It also provides functions to generate random instances.","category":"page"},{"location":"instance_loaders/#Loading-instances-from-files","page":"InstanceLoaders","title":"Loading instances from files","text":"","category":"section"},{"location":"instance_loaders/","page":"InstanceLoaders","title":"InstanceLoaders","text":"The Base.read function can be used to load an instance from a file. It takes as input the path to the file and returns an instance. There are two types of specification: StandardSpecification and TaillardSpecification.","category":"page"},{"location":"instance_loaders/","page":"InstanceLoaders","title":"InstanceLoaders","text":"StandardSpecification\nTaillardSpecification","category":"page"},{"location":"instance_loaders/#ShopAlgorithms.InstanceLoaders.StandardSpecification","page":"InstanceLoaders","title":"ShopAlgorithms.InstanceLoaders.StandardSpecification","text":"StandardSpecification <: JobShopFileSpecification\n\nA struct that represents a standard job shop instance specification. Standard instances are specified in the following format:\n\nn m\nμ_11 p_11 μ_12 p_12 ... μ_1n_1 p_1n_1\nμ_21 p_21 μ_22 p_22 ... μ_2n_2 p_2n_2\n...\nμ_m1 p_m1 μ_m2 p_m2 ... μ_mn_m p_mn_m\n\nwhere n is the number of jobs, m is the number of machines, p_ij is the processing time of job i on machine j, and μ_ij is the machine number of the jth operation of job i, starting from 0.\n\nFields\n\ninstance::JobShopInstance: A job shop instance.\n\nExamples\n\njulia> instance = JobShopInstance(3, 2, [2, 2, 2], [[1, 2], [2, 1], [1, 2]], [[1, 2], [2, 1], [1, 2]])\nJobShopInstance(3, 2, [2, 2, 2], [[1, 2], [2, 1], [1, 2]], [[1, 2], [2, 1], [1, 2]])\njulia> specification = StandardSpecification(instance)\nStandardSpecification(JobShopInstance(3, 2, [2, 2, 2], [[1, 2], [2, 1], [1, 2]], [[1, 2], [2, 1], [1, 2]]))\njulia> write(\"test.txt\", specification);\njulia> read(\"test.txt\", StandardSpecification)\nStandardSpecification(JobShopInstance(3, 2, [2, 2, 2], [[1, 2], [2, 1], [1, 2]], [[1, 2], [2, 1], [1, 2]]))\n\n\n\n\n\n","category":"type"},{"location":"instance_loaders/#ShopAlgorithms.InstanceLoaders.TaillardSpecification","page":"InstanceLoaders","title":"ShopAlgorithms.InstanceLoaders.TaillardSpecification","text":"TaillardSpecification <: JobShopFileSpecification\n\nA struct that represents a Taillard instance specification for the Job Shop Problem. Taillard instances are specified in the following format:\n\nn m\np_11 p_12 ... p_1n_1\np_21 p_22 ... p_2n_2\n...\np_m1 p_m2 ... p_mn_m\nμ_11 μ_12 ... μ_1n_1\nμ_21 μ_22 ... μ_2n_2\n...\nμ_m1 μ_m2 ... μ_mn_m\n\nwhere n is the number of jobs, m is the number of machines, p_ij is the processing time of job i on machine j, and μ_ij is the machine number of the jth operation of job i.\n\nFields\n\ninstance::JobShopInstance: A JobShopInstance object representing the instance.\n\nExamples\n\njulia> instance = JobShopInstance(3, 2, [2, 2, 2], [[1, 2], [2, 1], [1, 2]], [[1, 2], [2, 1], [1, 2]])\nJobShopInstance(3, 2, [2, 2, 2], [[1, 2], [2, 1], [1, 2]], [[1, 2], [2, 1], [1, 2]])\njulia> specification = TaillardSpecification(instance)\nTaillardSpecification(JobShopInstance(3, 2, [2, 2, 2], [[1, 2], [2, 1], [1, 2]], [[1, 2], [2, 1], [1, 2]]))\njulia> write(\"test.txt\", specification)\njulia> read(\"test.txt\", TaillardSpecification)\nTaillardSpecification(JobShopInstance(3, 2, [2, 2, 2], [[1, 2], [2, 1], [1, 2]], [[1, 2], [2, 1], [1, 2]]))\n\n\n\n\n\n","category":"type"},{"location":"instance_loaders/","page":"InstanceLoaders","title":"InstanceLoaders","text":"# Reading a instance\nBase.read(data::IO, ::Type{T}) where {T <: JobShopFileSpecification} ","category":"page"},{"location":"instance_loaders/#Saving-instances-to-files","page":"InstanceLoaders","title":"Saving instances to files","text":"","category":"section"},{"location":"instance_loaders/","page":"InstanceLoaders","title":"InstanceLoaders","text":"The Base.write function can be used to save an instance to a file. It takes as input the path to the file and the instance.","category":"page"},{"location":"instance_loaders/","page":"InstanceLoaders","title":"InstanceLoaders","text":"# Writing a instance\nBase.write(data::IO, specification::T) where {T <: JobShopFileSpecification}","category":"page"},{"location":"instance_loaders/#Generating-random-instances","page":"InstanceLoaders","title":"Generating random instances","text":"","category":"section"},{"location":"instance_loaders/","page":"InstanceLoaders","title":"InstanceLoaders","text":"The InstanceLoaders module provides functions to generate random instances. The random_instance_generator function can be used to generate a random instance. ","category":"page"},{"location":"instance_loaders/","page":"InstanceLoaders","title":"InstanceLoaders","text":"random_instance_generator","category":"page"},{"location":"instance_loaders/#ShopAlgorithms.InstanceLoaders.random_instance_generator","page":"InstanceLoaders","title":"ShopAlgorithms.InstanceLoaders.random_instance_generator","text":"random_instance_generator(n::Int64, m::Int64; n_i::Union{Vector{Int}, Nothing}=nothing, pMin::Int=1, pMax::Int=10, rng=default_rng(), job_recirculation::Bool=false, machine_repetition::Bool=false)::JobShopInstance\n\nThis function generates a random instance of the Job Shop Scheduling problem.\n\nArguments\n\nn::Int64: number of jobs.\nm::Int64: number of machines.\nn_i::Union{Vector{Int}, Nothing}=nothing: number of operations for each job. If nothing, all jobs have the same number m of operations.\npMin::Int=1: minimum processing time for an operation.\npMax::Int=10: maximum processing time for an operation.\nrng=default_rng(): random number generator.\njob_recirculation::Bool=false: if true, a job can be processed in the same machine more than once.\nmachine_repetition::Bool=false: if true, an operation can be processed in the same machine more than once in a row. If false, an operation cannot be processed in the same machine as the previous operation.\n\nReturns\n\nJobShopInstance: a random instance of the Job Shop Scheduling problem.\n\n\n\n\n\n","category":"function"},{"location":"plotters/#Plotters","page":"Plotters","title":"Plotters","text":"","category":"section"},{"location":"plotters/","page":"Plotters","title":"Plotters","text":"The Plotters module provides functions to plot the results of the algorithms.","category":"page"},{"location":"plotters/#Plotting-the-results-of-an-algorithm","page":"Plotters","title":"Plotting the results of an algorithm","text":"","category":"section"},{"location":"plotters/","page":"Plotters","title":"Plotters","text":"The gantt_chart function can be used to plot the gantt chart of an algorithm. It takes as input the algorithm results and the instance. The algorithm results can be obtained by via proper function from module Algortihms.","category":"page"},{"location":"plotters/","page":"Plotters","title":"Plotters","text":"gantt_chart","category":"page"},{"location":"plotters/#ShopAlgorithms.Plotters.gantt_chart","page":"Plotters","title":"ShopAlgorithms.Plotters.gantt_chart","text":"gantt_chart(solution::ShopSchedule)\n\nCreate a Gantt chart for a given ShopSchedule solution.\n\nArguments\n\nsolution::ShopSchedule: A ShopSchedule object representing a solution to a job shop scheduling problem.\n\nReturns\n\nA plot of the solution using a Gantt chart.\n\n\n\n\n\n","category":"function"},{"location":"plotters/","page":"Plotters","title":"Plotters","text":"The plot_geometric_approach function can be used to plot the geometric approach of an two jobs problem.","category":"page"},{"location":"plotters/","page":"Plotters","title":"Plotters","text":"plot_geometric_approach","category":"page"},{"location":"plotters/#ShopAlgorithms.Plotters.plot_geometric_approach","page":"Plotters","title":"ShopAlgorithms.Plotters.plot_geometric_approach","text":"plot_geometric_approach(solution::ShopSchedule; title::Union{Nothing,String}=nothing, width=800, height=800, aspectmode=\"auto\")\n\nThis function takes a ShopSchedule object as input and returns a plot of the solution using a geometric approach, when n == 2.  Plot is generated using PlotlyJS.\n\nArguments\n\nsolution::ShopSchedule: A ShopSchedule object representing the solution to a job shop scheduling problem.\ntitle::Union{Nothing,String}=nothing: Title of the plot. If nothing, the title will be the name of the instance.\nwidth=800: Width of the plot.\nheight=800: Height of the plot.\naspectmode=\"auto\": Aspect mode of the plot.\n\nReturns\n\nA plot of the solution using a geometric approach.\n\nExamples\n\njulia> instance = random_instance_generator(2,5);\njulia> solution = two_jobs_job_shop(instance);\njulia> plot_geometric_approach(solution)\n\n\n\n\n\n","category":"function"},{"location":"shop_instances/#ShopInstances","page":"ShopInstances","title":"ShopInstances","text":"","category":"section"},{"location":"shop_instances/","page":"ShopInstances","title":"ShopInstances","text":"Package to define and work with instances of the Job Shop Scheduling Problem.","category":"page"},{"location":"shop_instances/","page":"ShopInstances","title":"ShopInstances","text":"Modules = [ShopInstances]\nOrder   = [:constant, :type, :function]\nPrivate = false","category":"page"},{"location":"shop_instances/#ShopAlgorithms.ShopInstances.AbstractShop","page":"ShopInstances","title":"ShopAlgorithms.ShopInstances.AbstractShop","text":"AbstractShop\n\nAbstract type representing a shop problem.\n\n\n\n\n\n","category":"type"},{"location":"shop_instances/#ShopAlgorithms.ShopInstances.JobShopInstance","page":"ShopInstances","title":"ShopAlgorithms.ShopInstances.JobShopInstance","text":"struct JobShopInstance <: AbstractShop\n\nJobShopInstance(\n    n::Int64,\n    m::Int64,\n    n_i::Vector{Int},\n    p::Vector{Vector{Int}},\n    μ::Vector{Vector{Int}};\n    d::Vector{Int}=zeros(Int64, n),\n    name::String=\"\"\n)\n\nJobShopInstance represents a job shop instance, which is a type of scheduling problem.\n\nArguments\n\nn::Int64: number of jobs\nm::Int64: number of machines\nn_i::Vector{Int}: number of operations for each job\np::Vector{Vector{Int}}: processing times for each operation\nμ::Vector{Vector{Int}}: machines assigned to each operation\nd::Vector{Int} = zeros(Int64, n): due dates for each job\nname::String = \"\": name of the instance\n\nFields\n\nn: an integer representing the number of jobs\nm: an integer representing the number of machines\nn_i: a vector of integers representing the number of operations for each job\np: a vector of vectors of integers representing the processing times for each operation\nμ: a vector of vectors of integers representing the machines assigned to each operation\nd: a vector of integers representing the due dates for each job\nname: a string representing the name of the instance\n\n\n\n\n\n","category":"type"},{"location":"shop_instances/#ShopAlgorithms.ShopInstances.ObjectiveFunction","page":"ShopInstances","title":"ShopAlgorithms.ShopInstances.ObjectiveFunction","text":"Enum representing different objective functions for shop scheduling problems.\n\n\n\n\n\n","category":"type"},{"location":"shop_instances/#ShopAlgorithms.ShopInstances.ShopError","page":"ShopInstances","title":"ShopAlgorithms.ShopInstances.ShopError","text":"ShopError <: ShopResult\n\nShopError(\n    instance::AbstractShop,\n    error::String,\n    objectiveFunction::ObjectiveFunction;\n    algorithm::String=\"\",\n    metadata::Dict{String, Any}=Dict{String, Any}(),\n    date::DateTime=now()\n)\n\nA struct representing an error result of a shop scheduling algorithm.\n\nArguments\n\ninstance::AbstractShop: The instance of the shop problem.\nerror::String: The error message.\nobjectiveFunction::ObjectiveFunction: The objective function used in the algorithm.\n`algorithm::String=\"\": The name of the algorithm used.\nmetadata::Dict{String, Any}=Dict{String, Any}(): Additional metadata about the result.\ndate::DateTime=now(): The date and time when the result was obtained.\n\nFields\n\ninstance::JobShopInstance: The instance of the shop problem.\nerror::String: The error message.\nobjectiveFunction::ObjectiveFunction: The objective function used in the algorithm.\nalgorithm::String: The name of the algorithm used.\ndate::DateTime: The date and time when the result was obtained.\nmetadata::Dict{String, Any}: Additional metadata about the result.\n\n\n\n\n\n","category":"type"},{"location":"shop_instances/#ShopAlgorithms.ShopInstances.check_feasability-Tuple{ShopSchedule}","page":"ShopInstances","title":"ShopAlgorithms.ShopInstances.check_feasability","text":"check_feasability(schedule::ShopSchedule)\n\nCheck the feasability of a given schedule for a job-shop problem instance.\n\nArguments\n\nschedule::ShopSchedule: A schedule for a job-shop problem instance.\n\nReturns\n\ntrue if the schedule is feasible, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"shop_instances/#ShopAlgorithms.ShopInstances.dataframe_to_schedules-Tuple{DataFrames.DataFrame}","page":"ShopInstances","title":"ShopAlgorithms.ShopInstances.dataframe_to_schedules","text":"dataframe_to_schedules(df::DataFrame)::Vector{ShopSchedule}\n\nConverts a DataFrame to a Vector of ShopSchedule objects. The DataFrame should have the following columns:\n\nsolution_id: unique identifier for each solution\nname: name of the instance\nm: number of machines\nn: number of jobs\nalgorithm: name of the algorithm used to generate the solution\nmicroruns: number of microruns used by the algorithm\ntimeSeconds: time in seconds used by the algorithm\nmemoryBytes: memory used by the algorithm\njob: job number\noperation: operation number\nendtime: end time of the operation\nprocessing_time: processing time of the operation\nmachine: machine number where the operation was executed\nd: due date of the job\n\nReturns a Vector of ShopSchedule objects, each representing a solution in the DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"shop_graphs/#ShopGraphs","page":"ShopGraphs","title":"ShopGraphs","text":"","category":"section"},{"location":"shop_graphs/","page":"ShopGraphs","title":"ShopGraphs","text":"Package ShopGraphs provides a set of functions for working with graphs dedicated to the Job Shop Scheduling Problem.","category":"page"},{"location":"shop_graphs/","page":"ShopGraphs","title":"ShopGraphs","text":"Modules = [ShopGraphs]\nOrder   = [:constant, :type, :function]\nPrivate = false","category":"page"},{"location":"shop_graphs/#ShopAlgorithms.ShopGraphs.DiWeightedEdge","page":"ShopGraphs","title":"ShopAlgorithms.ShopGraphs.DiWeightedEdge","text":"mutable struct DiWeightedEdge{T<:Integer, U<:Real} <: AbstractEdge{T}\n\n    DiWeightedEdge is a mutable struct that represents a weighted edge in a graph. It contains the source vertex, destination vertex, and weight of the edge.\n\nArguments\n\nsrc::T: The source vertex of the edge.\ndst::T: The destination vertex of the edge.\nweight::U: The weight of the edge.\n\nType parameters\n\nT<:Integer: The type of the vertices.\nU<:Real: The type of the weight.\n\n\n\n\n\n","category":"type"},{"location":"shop_graphs/#ShopAlgorithms.ShopGraphs.DisjunctiveWeightedGraph","page":"ShopGraphs","title":"ShopAlgorithms.ShopGraphs.DisjunctiveWeightedGraph","text":"mutable struct DisjunctiveWeightedGraph{T<:Integer, U<:Real} <: AbstractGraph{T}\n\nDisjunctiveWeightedGraph is a mutable struct that represents a disjunctive weighted graph. It contains two fields:\n\nconjunctiveGraph: a SimpleDirectedWeightedGraphAdj{T,U} representing the conjunctive graph.\nselection: a SimpleDirectedWeightedGraphAdj{T,U} representing the selection of disjunctive graph.\n\nArguments\n\nT::Type{<:Integer}: The integer type of the vertices.\nU::Type{<:Real}: The real type of the weights.\n\nFields\n\nconjunctiveGraph::SimpleDirectedWeightedGraphAdj{T,U}: The conjunctive graph.\nselection::SimpleDirectedWeightedGraphAdj{T,U}: The selection of disjunctive graph.\n\nConstructors\n\nDisjunctiveWeightedGraph{T,U}(conjunctiveGraph::SimpleDirectedWeightedGraphAdj{T,U}, selection::SimpleDirectedWeightedGraphAdj{T,U}): Constructs a new DisjunctiveWeightedGraph{T,U} with the given conjunctiveGraph and selection.\n\nExamples\n\n    conjuctiveGraph = SimpleDirectedWeightedGraphAdj{Int,Int}([\n        [SimpleDirectedWeightedEdge(1, 2, 1), SimpleDirectedWeightedEdge(1, 3, 1)],\n        [SimpleDirectedWeightedEdge(2, 4, 1)],\n        [SimpleDirectedWeightedEdge(3, 4, 1)],\n        [SimpleDirectedWeightedEdge(4, 5, 1)]\n    ])\n    selection = SimpleDirectedWeightedGraphAdj{Int,Int}([\n        [SimpleDirectedWeightedEdge(1, 2, 1), SimpleDirectedWeightedEdge(1, 3, 1)],\n        [SimpleDirectedWeightedEdge(2, 4, 1)],\n        [SimpleDirectedWeightedEdge(3, 4, 1)],\n        [SimpleDirectedWeightedEdge(4, 5, 1)]\n    ])\n    disjunctiveWeightedGraph = DisjunctiveWeightedGraph(conjuctiveGraph, selection)\n\n\n\n\n\n","category":"type"},{"location":"shop_graphs/#ShopAlgorithms.ShopGraphs.SimpleDiWeightedGraphAdj","page":"ShopGraphs","title":"ShopAlgorithms.ShopGraphs.SimpleDiWeightedGraphAdj","text":"SimpleDiWeightedGraphAdj{T<:Integer, U<:Real}\n\nA simple directed weighted graph implementation using an adjacency list representation.\n\nFields\n\nedges::Vector{Vector{DiWeightedEdge{T,U}}}: A vector of out edges represented as a vector of DiWeightedEdge{T,U}.\nedges_transpose::Vector{Vector{DiWeightedEdge{T,U}}}: A vector of in edges represented as a vector of DiWeightedEdge{T,U}.\n\nConstructors\n\nSimpleDiWeightedGraphAdj{T,U}(edges::Vector{Vector{DiWeightedEdge{T,U}}}): Constructs a new SimpleDiWeightedGraphAdj{T,U} object with the given vertices and edges.\n\n\n\n\n\n","category":"type"},{"location":"shop_graphs/#ShopAlgorithms.ShopGraphs.dag_paths-Union{Tuple{V}, Tuple{Graphs.AbstractGraph, V, Symbol}} where V<:Integer","page":"ShopGraphs","title":"ShopAlgorithms.ShopGraphs.dag_paths","text":"dag_paths(graph::AbstractGraph, source::V, type::Symbol) where {V<:Integer, U<:Real}\n\nReturns all paths from the source vertex to all other vertices in a directed acyclic graph (DAG).\n\nArguments\n\ngraph::AbstractGraph: A directed acyclic graph.\nsource::V: The source vertex.\ntype::Symbol: The type of path to return. Possible values are :shortest and :longest.\nreversed::Bool: Whether to use the reversed graph.\n\nReturns\n\ndist::Vector{V}: A vector of distances from the source vertex to all other vertices.\n\nThrows\n\nArgumentError: If the type is not :shortest or :longest, or if the graph is not a DAG.\n\n\n\n\n\n","category":"method"},{"location":"shop_graphs/#ShopAlgorithms.ShopGraphs.topological_sort_util-Union{Tuple{V}, Tuple{Graphs.AbstractGraph, BitVector, BitVector, DataStructures.Stack{V}, V, Bool}} where V<:Integer","page":"ShopGraphs","title":"ShopAlgorithms.ShopGraphs.topological_sort_util","text":"topological_sort_util(graph::AbstractGraph, visited::BitVector, pathVis::BitVector, stack::Stack{V}, v::V) where {V<:Integer, U<:Real}\n\nA utility function used in topological sorting of a directed acyclic graph (DAG). This function recursively visits all the vertices adjacent to the given vertex v and adds them to the stack in topological order. It also detects cycles in the graph by keeping track of the visited vertices and the vertices in the current path.\n\nArguments\n\ngraph::AbstractGraph: The directed acyclic graph to be sorted.\nvisited::BitVector: A bit vector to keep track of the visited vertices.\npathVis::BitVector: A bit vector to keep track of the vertices in the current path.\nstack::Stack{V}: A stack to store the vertices in topological order.\nv::V: The vertex to be visited.\nreversed::Bool: Whether to use the reversed graph.\n\nReturns\n\nnothing\n\nThrows\n\nArgumentError: If the graph is not a DAG.\n\n\n\n\n\n","category":"method"},{"location":"#ShopAlgorithms-documentation","page":"Home","title":"ShopAlgorithms documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Main documentation for ShopAlgorithms.jl. This package provides a framework for solving shop scheduling problems. It is a part of a project for my master thesis. ","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Currently, this package is not registered in a Julia Packages Registry. To install it, run the following command in the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg\nPkg.add(https://github.com/mteplicki/JobShopAlgorithms)","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using ShopAlgorithms\ninstance = read(\"path/to/instance\", InstanceLoaders.StandardSpecification)\nresults = Algorithms.bnbcarlier(instance)\nprintln(results)","category":"page"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package consists of the following submodules:","category":"page"},{"location":"","page":"Home","title":"Home","text":"ShopAlgorithms\nShopAlgorithms.Algorithms\nShopAlgorithms.ShopInstances\nShopAlgorithms.InstanceLoaders\nShopAlgorithms.Plotters\nShopAlgorithms.Constraints\nShopAlgorithms.ShopGraphs","category":"page"},{"location":"#ShopAlgorithms","page":"Home","title":"ShopAlgorithms","text":"This module contains the implementation of algorithms for solving job shop scheduling problems. It exports the following modules: Algorithms, ShopInstances, InstanceLoaders, Plotters, Constraints, ShopGraphs.\n\n\n\n\n\n","category":"module"},{"location":"#ShopAlgorithms.Algorithms","page":"Home","title":"ShopAlgorithms.Algorithms","text":"Module containing various Job Shop algorithms.\n\n\n\n\n\n","category":"module"},{"location":"#ShopAlgorithms.ShopInstances","page":"Home","title":"ShopAlgorithms.ShopInstances","text":"This module contains the implementation of various job shop instances, as well as the necessary functions and types to work with them. \n\n\n\n\n\n","category":"module"},{"location":"#ShopAlgorithms.InstanceLoaders","page":"Home","title":"ShopAlgorithms.InstanceLoaders","text":"Module for loading and generating random instances of the Shop Problem.\n\n\n\n\n\n","category":"module"},{"location":"#ShopAlgorithms.Plotters","page":"Home","title":"ShopAlgorithms.Plotters","text":"Module for plotting functions and data.\n\n\n\n\n\n","category":"module"},{"location":"#ShopAlgorithms.Constraints","page":"Home","title":"ShopAlgorithms.Constraints","text":"This module contains functions that define constraints for the job shop scheduling problem. Every method in a module should return a function that takes an instance of the problem and returns a boolean value.\n\n\n\n\n\n","category":"module"},{"location":"#ShopAlgorithms.ShopGraphs","page":"Home","title":"ShopAlgorithms.ShopGraphs","text":"This module defines functions and types for working with graphs dedicated for Job Shop algortihms.\n\n\n\n\n\n","category":"module"},{"location":"#Extensions","page":"Home","title":"Extensions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To extend the package, you can define your own algorithms. To do so, you need to define a function that takes as input an instance and returns a ShopResult object. ","category":"page"},{"location":"algorithms/#Algorithms","page":"Algorithms","title":"Algorithms","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Package Algorithms is a main submodule of a project. It provides a set of functions for working with algorithms dedicated to the Job Shop Scheduling Problem.","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Modules = [Algorithms]\nOrder   = [:constant, :type, :function]\nPrivate = false","category":"page"},{"location":"algorithms/#ShopAlgorithms.Algorithms.algorithm2_two_machines_job_shop-Tuple{JobShopInstance}","page":"Algorithms","title":"ShopAlgorithms.Algorithms.algorithm2_two_machines_job_shop","text":"algorithm2_two_machines_job_shop(instance::JobShopInstance; yielding::Bool=false)\n\nAlgorithm to solve a J2 | n=k | Cmax problem, with complexity O(r^k), where r = sum(n_i) and k = n.\n\nArguments\n\ninstance::JobShopInstance: An instance of the two machines job shop problem.\nyielding::Bool=false: If true, the algorithm will yield after each iteration. This is useful for timeouting the algorithm.\n\nReturns\n\njobShopSchedule::ShopSchedule: A ShopSchedule object representing the solution to the two machines job shop problem.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/#ShopAlgorithms.Algorithms.branchandbound-Tuple{JobShopInstance}","page":"Algorithms","title":"ShopAlgorithms.Algorithms.branchandbound","text":"branchandbound(\n    instance::JobShopInstance;\n    bounding_algorithm::Symbol=:no_pmtn,\n    yielding::Bool=false,\n    io_print_best_node::Union{IO, Nothing} = nothing,\n    heuristic_UB::Bool = false,\n)\n\nBranch and Bound algorithm for the Job Shop Scheduling problem J | rcrc | Cmax with recirculation.\n\nArguments\n\ninstance::JobShopInstance: A job shop instance.\nbounding_algorithm::Symbol=:no_pmtn: Algorithm used to bound the lower bound of the solution. Possible values are :no_pmtn for 1 | r_j | Lmax and :pmtn for 1 | r_j, pmtn | Lmax. Default value is :no_pmtn.\nyielding::Bool=false: If true, the algorithm will yield after each iteration. This is useful for timeouting the algorithm.\nio_print_best_node::Union{IO, Nothing} = nothing: If not nothing, the algorithm will print the best node found so far to the given IO.\nheuristic_UB::Bool=false: If true, the algorithm will use the Shifting Bottleneck algorithm to find the upper bound of the solution.\n\nReturns\n\nShopSchedule: A ShopSchedule object representing the solution to the job shop problem.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/#ShopAlgorithms.Algorithms.branchandbound_carlier-Tuple{JobShopInstance}","page":"Algorithms","title":"ShopAlgorithms.Algorithms.branchandbound_carlier","text":"branchandbound_carlier(\n    instance::JobShopInstance;\n    yielding::Bool = false,\n    with_dpc::Bool = false,\n    with_priority_queue::Bool = false,\n    io_print_best_node::Union{IO, Nothing} = nothing,\n    heuristic_UB::Bool = false\n)\n\nBranch and Bound algorithm for the Job Shop Scheduling problem J || Cmax with no recirculation.\n\nArguments\n\ninstance::JobShopInstance: A job shop instance.\nyielding::Bool=false: If true, the algorithm will yield after each iteration. This is useful for timeouting the algorithm.\nwith_dpc::Bool=true: If true, the algorithm will use the DPC algorithm to find the longest path in the graph. Otherwise, the algorithm will use the Carlier algorithm.\nwith_priority_queue::Bool=true: If true, the algorithm will use a priority queue to find the node in Carlier algorithm. Otherwise, it will use a simple stack.\nio_print_best_node::Union{IO, Nothing} = nothing: If not nothing, the algorithm will print the best node found so far to the given IO.\nheuristic_UB::Bool=false: If true, the algorithm will use the Shifting Bottleneck algorithm to find the upper bound of the solution.\n\nReturns\n\nShopSchedule: A ShopSchedule object representing the solution to the job shop problem.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/#ShopAlgorithms.Algorithms.shiftingbottleneck-Tuple{JobShopInstance}","page":"Algorithms","title":"ShopAlgorithms.Algorithms.shiftingbottleneck","text":"shiftingbottleneck(\n    instance::JobShopInstance;\n    suppress_warnings::Bool = false,\n    yielding::Bool = false,\n    machine_improving::Bool = true\n)\n\nSolves the job shop scheduling J || Cmax problem with no job recirculation using the Shifting Bottleneck algorithm. The solution of the problem  is not guaranteed to be optimal. Also, not every instance of the problem can be solved using this algorithm.\n\nArguments\n\ninstance::JobShopInstance: An instance of the job shop scheduling problem.\nsuppress_warnings: If true, warnings will not be printed.\nyielding::Bool=false: If true, the algorithm will yield after each iteration. This is useful for timeouting the algorithm.\nmachine_improving::Bool=true: If true, the algorithm will try to improve the solution by fixing the disjunctive edges for each machine.\n\nReturns\n\nShopSchedule <: ShopResult: A ShopSchedule object representing the solution to the job shop problem.\nShopError <: ShopResult: A ShopError object representing the error that occured during the execution of the algorithm.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/#ShopAlgorithms.Algorithms.shiftingbottleneckcarlier-Tuple{JobShopInstance}","page":"Algorithms","title":"ShopAlgorithms.Algorithms.shiftingbottleneckcarlier","text":"shiftingbottleneckcarlier(\n    instance::JobShopInstance; \n    yielding::Bool = false, \n    with_priority_queue::Bool = true,\n    with_dpc::Bool = true, \n    carlier_timeout::Union{Nothing,Float64} = nothing, \n    machine_improving::Bool = true,\n    carlier_depth::Int64=typemax(Int64)\n    )\n\nSolves the job shop scheduling J || Cmax problem with recirculation allowed using the Shifting Bottleneck algorithm with Carlier algorithm. The solution of the problem is not guaranteed to be optimal.\n\nArguments\n\ninstance::JobShopInstance: An instance of the job shop scheduling problem.\nyielding::Bool=false: If true, the algorithm will yield after each iteration. This is useful for timeouting the algorithm.\nwith_dpc::Bool=true: If true, the algorithm will use the Carlier DPC algorithm to find the longest path in the graph. Otherwise, the algorithm will use the Carlier algorithm.\nwith_priority_queue::Bool=true: If true, the algorithm will use a priority queue to find the longest path in Carlier algorithm. Otherwise, it will use a simple stack.\ncarlier_timeout::Union{Nothing,Float64}=nothing: If not nothing, the inner Carlier algorithm will be timeouted after carlier_timeout seconds.\nmachine_improving::Bool=true: If true, the algorithm will try to improve the solution by fixing the disjunctive edges for each machine.\ncarlier_depth::Int64=typemax(Int64): If not typemax(Int64), the inner Carlier algorithm finding artificial paths will be limited to carlier_depth depth from the real path.\n\nReturns\n\nShopSchedule <: ShopResult: A ShopSchedule object representing the solution to the job shop problem. The solution is not guaranteed to be optimal.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/#ShopAlgorithms.Algorithms.two_jobs_job_shop-Tuple{JobShopInstance}","page":"Algorithms","title":"ShopAlgorithms.Algorithms.two_jobs_job_shop","text":"two_jobs_job_shop(instance::JobShopInstance; yielding::Bool=false)\n\nSolves the two jobs job shop J  n=2  Cmax problem for a given instance of JobShopInstance with recirculation and machine repetition allowed. Complexity: O(r log r), where r = sum(n_i) is the number of operations.\n\nArguments\n\ninstance::JobShopInstance: An instance of the job shop problem.\nyielding::Bool=false: If true, the algorithm will yield after each iteration. This is useful for timeouting the algorithm.\n\nReturns\n\nShopSchedule: A ShopSchedule object representing the solution to the job shop problem.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/#ShopAlgorithms.Algorithms.two_machines_job_shop-Tuple{JobShopInstance}","page":"Algorithms","title":"ShopAlgorithms.Algorithms.two_machines_job_shop","text":"two_machines_job_shop(instance::JobShopInstance; yielding::Bool=false)\n\nSolves the two-machine job shop problem J2 | p_ij = 1 | Lmax for the given instance. Complexity is O(r), where r = sum(n_i) is the number of operations.\n\nArguments\n\ninstance::JobShopInstance: An instance of the two-machine job shop problem.\nyielding::Bool=false: If true, the algorithm will yield after each iteration. This is useful for timeouting the algorithm.\n\nReturns\n\nAn optimal solution to the two-machine job shop problem.\n\n\n\n\n\n","category":"method"}]
}
