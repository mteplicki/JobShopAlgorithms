<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Algorithms · ShopAlgorithms.jl</title><meta name="title" content="Algorithms · ShopAlgorithms.jl"/><meta property="og:title" content="Algorithms · ShopAlgorithms.jl"/><meta property="twitter:title" content="Algorithms · ShopAlgorithms.jl"/><meta name="description" content="Documentation for ShopAlgorithms.jl."/><meta property="og:description" content="Documentation for ShopAlgorithms.jl."/><meta property="twitter:description" content="Documentation for ShopAlgorithms.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ShopAlgorithms.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Algorithms</a></li><li><a class="tocitem" href="../constraints/">Constraints</a></li><li><a class="tocitem" href="../instance_loaders/">InstanceLoaders</a></li><li><a class="tocitem" href="../plotters/">Plotters</a></li><li><a class="tocitem" href="../shop_graphs/">ShopGraphs</a></li><li><a class="tocitem" href="../shop_instances/">ShopInstances</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Algorithms</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Algorithms</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mteplicki/JobShopAlgorithms" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mteplicki/JobShopAlgorithms/blob/main/docs/src/algorithms.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Algorithms"><a class="docs-heading-anchor" href="#Algorithms">Algorithms</a><a id="Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithms" title="Permalink"></a></h1><p>Package <code>Algorithms</code> is a main submodule of a project. It provides a set of functions for working with algorithms dedicated to the Job Shop Scheduling Problem.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ShopAlgorithms.Algorithms.algorithm2_two_machines_job_shop-Tuple{JobShopInstance}" href="#ShopAlgorithms.Algorithms.algorithm2_two_machines_job_shop-Tuple{JobShopInstance}"><code>ShopAlgorithms.Algorithms.algorithm2_two_machines_job_shop</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">algorithm2_two_machines_job_shop(instance::JobShopInstance; yielding::Bool=false)</code></pre><p>Algorithm to solve a <code>J2 | n=k | Cmax</code> problem, with complexity <code>O(r^k)</code>, where <code>r = sum(n_i)</code> and <code>k = n</code>.</p><p><strong>Arguments</strong></p><ul><li><code>instance::JobShopInstance</code>: An instance of the two machines job shop problem.</li><li><code>yielding::Bool=false</code>: If <code>true</code>, the algorithm will yield after each iteration. This is useful for timeouting the algorithm.</li></ul><p><strong>Returns</strong></p><ul><li><code>jobShopSchedule::ShopSchedule</code>: A ShopSchedule object representing the solution to the two machines job shop problem.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mteplicki/JobShopAlgorithms/blob/5479476cd9594ab0cc40b45da9188b066ea039ee/src/algorithms/algorithm2_twomachinesjobshop.jl#L20-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ShopAlgorithms.Algorithms.branchandbound-Tuple{JobShopInstance}" href="#ShopAlgorithms.Algorithms.branchandbound-Tuple{JobShopInstance}"><code>ShopAlgorithms.Algorithms.branchandbound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">branchandbound(
    instance::JobShopInstance;
    bounding_algorithm::Symbol=:no_pmtn,
    yielding::Bool=false,
    io_print_best_node::Union{IO, Nothing} = nothing,
    heuristic_UB::Bool = false,
)</code></pre><p>Branch and Bound algorithm for the Job Shop Scheduling problem <code>J | rcrc | Cmax</code> with recirculation.</p><p><strong>Arguments</strong></p><ul><li><code>instance::JobShopInstance</code>: A job shop instance.</li><li><code>bounding_algorithm::Symbol=:no_pmtn</code>: Algorithm used to bound the lower bound of the solution. Possible values are <code>:no_pmtn</code> for <code>1 | r_j | Lmax</code> and <code>:pmtn</code> for <code>1 | r_j, pmtn | Lmax</code>. Default value is <code>:no_pmtn</code>.</li><li><code>yielding::Bool=false</code>: If <code>true</code>, the algorithm will yield after each iteration. This is useful for timeouting the algorithm.</li><li><code>io_print_best_node::Union{IO, Nothing} = nothing</code>: If not <code>nothing</code>, the algorithm will print the best node found so far to the given IO.</li><li><code>heuristic_UB::Bool=false</code>: If <code>true</code>, the algorithm will use the Shifting Bottleneck algorithm to find the upper bound of the solution.</li></ul><p><strong>Returns</strong></p><ul><li><code>ShopSchedule</code>: A ShopSchedule object representing the solution to the job shop problem.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mteplicki/JobShopAlgorithms/blob/5479476cd9594ab0cc40b45da9188b066ea039ee/src/algorithms/branch_and_bound_jobshop.jl#L6-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ShopAlgorithms.Algorithms.branchandbound_carlier-Tuple{JobShopInstance}" href="#ShopAlgorithms.Algorithms.branchandbound_carlier-Tuple{JobShopInstance}"><code>ShopAlgorithms.Algorithms.branchandbound_carlier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">branchandbound_carlier(
    instance::JobShopInstance;
    yielding::Bool = false,
    with_dpc::Bool = false,
    with_priority_queue::Bool = false,
    io_print_best_node::Union{IO, Nothing} = nothing,
    heuristic_UB::Bool = false
)</code></pre><p>Branch and Bound algorithm for the Job Shop Scheduling problem <code>J || Cmax</code> with no recirculation.</p><p><strong>Arguments</strong></p><ul><li><code>instance::JobShopInstance</code>: A job shop instance.</li><li><code>yielding::Bool=false</code>: If <code>true</code>, the algorithm will yield after each iteration. This is useful for timeouting the algorithm.</li><li><code>with_dpc::Bool=true</code>: If <code>true</code>, the algorithm will use the DPC algorithm to find the longest path in the graph. Otherwise, the algorithm will use the Carlier algorithm.</li><li><code>with_priority_queue::Bool=true</code>: If <code>true</code>, the algorithm will use a priority queue to find the node in Carlier algorithm. Otherwise, it will use a simple stack.</li><li><code>io_print_best_node::Union{IO, Nothing} = nothing</code>: If not <code>nothing</code>, the algorithm will print the best node found so far to the given IO.</li><li><code>heuristic_UB::Bool=false</code>: If <code>true</code>, the algorithm will use the Shifting Bottleneck algorithm to find the upper bound of the solution.</li></ul><p><strong>Returns</strong></p><ul><li><code>ShopSchedule</code>: A ShopSchedule object representing the solution to the job shop problem.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mteplicki/JobShopAlgorithms/blob/5479476cd9594ab0cc40b45da9188b066ea039ee/src/algorithms/branch_and_bound_carlier.jl#L6-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ShopAlgorithms.Algorithms.shiftingbottleneck-Tuple{JobShopInstance}" href="#ShopAlgorithms.Algorithms.shiftingbottleneck-Tuple{JobShopInstance}"><code>ShopAlgorithms.Algorithms.shiftingbottleneck</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shiftingbottleneck(
    instance::JobShopInstance;
    suppress_warnings::Bool = false,
    yielding::Bool = false,
    machine_improving::Bool = true
)</code></pre><p>Solves the job shop scheduling <code>J || Cmax</code> problem with no job recirculation using the Shifting Bottleneck algorithm. The solution of the problem  is not guaranteed to be optimal. Also, not every instance of the problem can be solved using this algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>instance::JobShopInstance</code>: An instance of the job shop scheduling problem.</li><li><code>suppress_warnings</code>: If <code>true</code>, warnings will not be printed.</li><li><code>yielding::Bool=false</code>: If <code>true</code>, the algorithm will yield after each iteration. This is useful for timeouting the algorithm.</li><li><code>machine_improving::Bool=true</code>: If <code>true</code>, the algorithm will try to improve the solution by fixing the disjunctive edges for each machine.</li></ul><p><strong>Returns</strong></p><ul><li><code>ShopSchedule &lt;: ShopResult</code>: A ShopSchedule object representing the solution to the job shop problem.</li><li><code>ShopError &lt;: ShopResult</code>: A ShopError object representing the error that occured during the execution of the algorithm.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mteplicki/JobShopAlgorithms/blob/5479476cd9594ab0cc40b45da9188b066ea039ee/src/algorithms/shifting_bottleneck.jl#L3-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ShopAlgorithms.Algorithms.shiftingbottleneckcarlier-Tuple{JobShopInstance}" href="#ShopAlgorithms.Algorithms.shiftingbottleneckcarlier-Tuple{JobShopInstance}"><code>ShopAlgorithms.Algorithms.shiftingbottleneckcarlier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shiftingbottleneckcarlier(
    instance::JobShopInstance; 
    yielding::Bool = false, 
    with_priority_queue::Bool = true,
    with_dpc::Bool = true, 
    carlier_timeout::Union{Nothing,Float64} = nothing, 
    machine_improving::Bool = true,
    carlier_depth::Int64=typemax(Int64)
    )</code></pre><p>Solves the job shop scheduling <code>J || Cmax</code> problem with recirculation allowed using the Shifting Bottleneck algorithm with Carlier algorithm. The solution of the problem is not guaranteed to be optimal.</p><p><strong>Arguments</strong></p><ul><li><code>instance::JobShopInstance</code>: An instance of the job shop scheduling problem.</li><li><code>yielding::Bool=false</code>: If <code>true</code>, the algorithm will yield after each iteration. This is useful for timeouting the algorithm.</li><li><code>with_dpc::Bool=true</code>: If <code>true</code>, the algorithm will use the Carlier DPC algorithm to find the longest path in the graph. Otherwise, the algorithm will use the Carlier algorithm.</li><li><code>with_priority_queue::Bool=true</code>: If <code>true</code>, the algorithm will use a priority queue to find the longest path in Carlier algorithm. Otherwise, it will use a simple stack.</li><li><code>carlier_timeout::Union{Nothing,Float64}=nothing</code>: If not <code>nothing</code>, the inner Carlier algorithm will be timeouted after <code>carlier_timeout</code> seconds.</li><li><code>machine_improving::Bool=true</code>: If <code>true</code>, the algorithm will try to improve the solution by fixing the disjunctive edges for each machine.</li><li><code>carlier_depth::Int64=typemax(Int64)</code>: If not <code>typemax(Int64)</code>, the inner Carlier algorithm finding artificial paths will be limited to <code>carlier_depth</code> depth from the real path.</li></ul><p><strong>Returns</strong></p><ul><li><code>ShopSchedule &lt;: ShopResult</code>: A ShopSchedule object representing the solution to the job shop problem. The solution is not guaranteed to be optimal.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mteplicki/JobShopAlgorithms/blob/5479476cd9594ab0cc40b45da9188b066ea039ee/src/algorithms/shifting_bottleneck_dpc.jl#L5-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ShopAlgorithms.Algorithms.two_jobs_job_shop-Tuple{JobShopInstance}" href="#ShopAlgorithms.Algorithms.two_jobs_job_shop-Tuple{JobShopInstance}"><code>ShopAlgorithms.Algorithms.two_jobs_job_shop</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">two_jobs_job_shop(instance::JobShopInstance; yielding::Bool=false)</code></pre><p>Solves the two jobs job shop <span>$J | n=2 | Cmax$</span> problem for a given <code>instance</code> of <code>JobShopInstance</code> with recirculation and machine repetition allowed. Complexity: <code>O(r log r)</code>, where <code>r = sum(n_i)</code> is the number of operations.</p><p><strong>Arguments</strong></p><ul><li><code>instance::JobShopInstance</code>: An instance of the job shop problem.</li><li><code>yielding::Bool=false</code>: If <code>true</code>, the algorithm will yield after each iteration. This is useful for timeouting the algorithm.</li></ul><p><strong>Returns</strong></p><ul><li><code>ShopSchedule</code>: A <code>ShopSchedule</code> object representing the solution to the job shop problem.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mteplicki/JobShopAlgorithms/blob/5479476cd9594ab0cc40b45da9188b066ea039ee/src/algorithms/two_jobs_job_shop.jl#L59-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ShopAlgorithms.Algorithms.two_machines_job_shop-Tuple{JobShopInstance}" href="#ShopAlgorithms.Algorithms.two_machines_job_shop-Tuple{JobShopInstance}"><code>ShopAlgorithms.Algorithms.two_machines_job_shop</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">two_machines_job_shop(instance::JobShopInstance; yielding::Bool=false)</code></pre><p>Solves the two-machine job shop problem <code>J2 | p_ij = 1 | Lmax</code> for the given <code>instance</code>. Complexity is <code>O(r)</code>, where <code>r = sum(n_i)</code> is the number of operations.</p><p><strong>Arguments</strong></p><ul><li><code>instance::JobShopInstance</code>: An instance of the two-machine job shop problem.</li><li><code>yielding::Bool=false</code>: If <code>true</code>, the algorithm will yield after each iteration. This is useful for timeouting the algorithm.</li></ul><p><strong>Returns</strong></p><ul><li>An optimal solution to the two-machine job shop problem.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mteplicki/JobShopAlgorithms/blob/5479476cd9594ab0cc40b45da9188b066ea039ee/src/algorithms/two_machines_job_shop.jl#L3-L15">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../constraints/">Constraints »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Friday 8 December 2023 13:08">Friday 8 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
